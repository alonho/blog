<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: VHDL | Alon Horev]]></title>
  <link href="http://alon.horev.net/blog/categories/vhdl/atom.xml" rel="self"/>
  <link href="http://alon.horev.net/"/>
  <updated>2012-12-04T12:35:55+02:00</updated>
  <id>http://alon.horev.net/</id>
  <author>
    <name><![CDATA[Alon Horev]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A hardware lesson for software developers: from logical gates to the game of life]]></title>
    <link href="http://alon.horev.net/blog/2012/12/03/a-hardware-lesson-for-software-developers-from-logical-gates-to-the-game-of-life/"/>
    <updated>2012-12-03T23:04:00+02:00</updated>
    <id>http://alon.horev.net/blog/2012/12/03/a-hardware-lesson-for-software-developers-from-logical-gates-to-the-game-of-life</id>
    <content type="html"><![CDATA[<p>About a week ago I've decided to learn VHDL and as an exercise, implement 'The game of life'.
VHDL is a hardware definition language. Meaning, a language that is compiled to hardware.</p>

<p><em>Why write this post? (or why I'm a mazochist as my friends ask)</em>
I thought it'd be interesting to see what it takes to develop a chip. I was specifically curious about the programming model and mindset.</p>

<p>I think every programmer should be familiar with the layers he relies on. Not every Python programmer knows C. And not every C programmer knows assembler. But when the shit hits the fan, this knowledge comes in handy.</p>

<p><em>pre-requisites</em>
I'm going to assume you know nothing about hardware and a little about software.
VHDL is based on Ada so you might even find it familiar.</p>

<h2>Booleans all the way down</h2>

<p>Most hardware these days deeply relies on boolean logic, here's why:</p>

<ul>
<li>Boolean algebra has been around for ages - simple boolean operations like 'and', 'or' and 'not' can compose incredibly sophisticated algorithms (modems, calculators, CPUs!).</li>
<li>Passing boolean data is easy in hardware, as you either pass electricity through a line to indicate a <strong>true</strong> state and stop passing electricity to indicate <strong>false</strong>.</li>
</ul>


<p>(Light bulb moment): ever wondered why integers in software are powers of two? or what's the difference between 32bit and 64bit?</p>

<p>A CPU has a fixed amount of wires (32/64) dedicated to represent data (a.k.a word size). each wire represents a bit that can be true or false (1 or 0). The binary numeral system is used to represent a number in a bunch of 1s and 0s.</p>

<h2>Dive into VHDL - the life of a gate</h2>

<p>Let's start off with an implementation of an 'and' gate:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>And Gate  (and.vhdl)</span> <a href='/downloads/code/and.vhdl'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ada'><span class='line'><span class="n">library</span> <span class="n">ieee</span><span class="p">;</span>
</span><span class='line'><span class="kn">use</span> <span class="nn">ieee.std_logic_1164.all</span><span class="p">;</span>	
</span><span class='line'>
</span><span class='line'><span class="n">entity</span> <span class="n">and_entity</span> <span class="kr">is</span>
</span><span class='line'>  <span class="n">port</span><span class="p">(</span>	
</span><span class='line'>    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="ow">in</span> <span class="n">std_logic</span><span class="p">;</span>
</span><span class='line'>    <span class="n">result</span><span class="p">:</span> <span class="kr">out</span> <span class="n">std_logic</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'><span class="kr">end</span> <span class="nf">and_entity</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">architecture</span> <span class="n">arch</span> <span class="kr">of</span> <span class="n">and_entity</span> <span class="kr">is</span>
</span><span class='line'><span class="kr">begin</span>
</span><span class='line'>  <span class="n">result</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'><span class="kr">end</span> <span class="nf">arch</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>What's happening in the code line by line:</p>

<p>1-2: Include the module that exports the std_logic type which is a simple bit (can be 0 or 1).
4: Define a new entity. An entity is analogous to an object in OOP.
5: the entity interacts with other entities using ports. input ports are used to receive information and output ports are used to send information.
6: define two inputs of type std_logic.
7: define one output of type std_logic.
14: the architecture is the implementation of the object's behavior. it's name (arch) is redundant as only one architecture is allowed.
16: the actual implementation of an 'and' gate. every time one of the inputs changes the output is recalcualted.</p>

<p>By using a synthesis tool we can convert this code to a hardware specification:</p>

<p>[image]</p>

<h2>Think Parallel - a simple adder</h2>

<p>An adder has two single bit inputs and a two-bit output: sum_0, sum_1
Here's a mapping for all possible inputs and outputs:</p>

<p>x + y = sum_1 sum_0 sum as binary sum as int
0   0   0     0     0             0
0   1   0     0     0             0
1   0   0     0     1             1
1   1   1     0     10            2</p>

<pre><code>library ieee;
use ieee.std_logic_1164.all;

entity adder is
port ( 
    x, y: in std_logic;
    sum_0, sum_1: out std_logic
);
end adder;

architecture arch of adder is 
begin

    sum_0 &lt;= x xor y;
    sum_1 &lt;= x and y;

end arch;
</code></pre>

<p>Look at lines 13-14. When does this code execute? is line 13 executed before line 14?
The answer is: these lines execute all the time, in parallel!</p>

<p>This is a major difference from software written for CPUs, <em>VHDL is concurrent by default</em>.</p>

<p>VHDL has the notion of <em>concurrent</em> statements and <em>sequential</em> statements. Sequential statments can be used to implement state machines and other sequential procedures. We'll see an example later on.</p>

<h2>Testing using sequential code</h2>

<p>VHDL programmers (often called designers) write tests frequently. they call them 'test benches' or 'simulations'.</p>

<p>The test will be a separate entity. In order to verify the adder's functionality we'll have to drive different inputs and check the sum.</p>

<p>CODE HERE</p>

<p>9-14: repetition of the adder's interface (VHDL isn't very DRY)
16: signals are wires that the test can manipulate. their type is std_logic so they can be set to zero or one
19-22: a port map connects the signals to the adder. The signals are named exactly as the adder's ports (the syntax: SIGNAL_NAME => PORT_NAME)
24: the process definition. A process contains a list of sequential statements. Multiple processes can run concurrently.
26-27: signal assignments.
28: signals have an interesting behavior where the assignment takes effect only when calling 'wait'. This is more a feature than a bug as it allows doing atomic changes over multiple signals.
29: make sure the sum changed</p>

<p>The following lines test the remaining test cases.</p>

<p>Here's the simulation in wave form:</p>

<p>IMAGE here</p>

<h2>The game of life</h2>

<p>In case you never heard about the game of life: http://en.wikipedia.org/wiki/Conway's_Game_of_Life</p>

<p>First, I want to present the typical software-based solution:
1. The board is a matrix of booleans representing cells.
2. For each cycle: the next board is generated by iterating over the matrix, for each cell: count it's neighbors and determine if it should be alive or dead.</p>

<p>When trying to apply this design in VHDL I quickly ran into brick walls. A sequential iteration over an entire matrix is not the VHDL 'way'. My guess is that a sequential design would generate much more logical gates and perhaps even be slower (In chip design you often watch out for the number of logical gates and hardware elements used compared to CPU and memory in software).</p>

<p>VHDL encourages you to build small components and inter-connect them where needed. each component has it's own hardware resources and can run independently and in parallel to others.</p>

<p>The design I came up with is the following:
1. <em>Cell</em> - is an entity. connected to it's neighbors via ports. has an independent process for counting the neighbors and setting the next state.
2. <em>Board</em> - is a matrix of cells. all it does is inter-connects them.</p>

<p>Here's the cell's code:</p>

<p>entity cell is</p>

<p>  generic (</p>

<pre><code>start_alive : integer range 0 to 1 := 0
</code></pre>

<p>  );</p>

<p>  port (</p>

<pre><code>clock, left, right,
upper_left, upper, upper_right,
lower_left, lower, lower_right : in integer range 0 to 1;
alive : inout integer range 0 to 1 := start_alive
</code></pre>

<p>  );</p>

<p>end cell;</p>

<p>architecture arch of cell is
begin</p>

<p>  process (clock)</p>

<pre><code>variable neighbors: integer range 0 to 8;
begin
  neighbors := upper_left + upper + upper_right + left +
               right + lower_left + lower + lower_right;
  if (neighbors = 3) or (alive = 1 and (neighbors) = 2) then
    alive &lt;= 1;
  else
    alive &lt;= 0;
  end if;
end process;
</code></pre>

<p>end arch;</p>

<p>3: generics are variables that can be set upon entity instantiation. similar to constructor arguments.
19: notice the process gets an argument? a process can state a list of signals (also called a sensitivity list) that should trigger it's invocation. that way, the cell will calculate it's next state every time the clock changes.
20: variables are exactly what you think they. notice we limit the integer's range to 8? that's because we'll have a maximum of 8 neighbors.</p>

<p>Conclusions</p>

<p>Why create new circuits and not use cpus? power consumption, performance, size, money, response time</p>

<p>software - write serial code, parallelize when need to scale.
hardware - write concurrent code, write serial code where needed.</p>

<p>One of the most challenging concepts in software is concurreny. It's interesting how fundamental this topic is to hardware.</p>

<p>Scalabillity - How the design scales for a large amount of cells?</p>

<pre><code>The software-based solution has several limits:
memory-wise: limited by the amount of memory
speed-wise: iteration is done serially and will be directly proportional to the amount of cells. (even if you utilize multiple cores)

The hardware-based solution is said to be scalable. adding more cells results in adding more logical gates. there is no performance overhead and no arbitrary limit on the number of cells in the matrix.
</code></pre>

<h2>Tools</h2>

<p>The eco-system around</p>

<p>ghdl (for mac!)
xilinix on windows or schematic generation
gtkwave using ghdl</p>
]]></content>
  </entry>
  
</feed>
